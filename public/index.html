<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Slither.io Multi</title>
  <meta name="viewport" content="width=900">
  <style>
    html, body {margin: 0; padding: 0; background: #111; overflow: hidden;}
    body {font-family: 'Segoe UI', Arial, sans-serif;}
    #ui {
      position: absolute; top: 0; left: 0; width: 100%; z-index: 10;
      pointer-events: none;
    }
    #score {
      color: #fff;
      font-size: 2rem;
      margin: 24px 0 0 24px;
      text-shadow: 0 0 8px #000a;
      position: absolute;
      left: 0; top: 0;
      pointer-events: none;
      user-select: none;
    }
    #restartBtn {
      display: none;
      position: absolute;
      left: 50%; top: 46%;
      transform: translate(-50%, -50%);
      background: #26293a;
      color: #fff;
      font-size: 1.5rem;
      padding: 22px 52px;
      border: none;
      border-radius: 16px;
      box-shadow: 0 0 16px #1d212c99;
      cursor: pointer;
      pointer-events: auto;
      transition: background .2s;
      outline: none;
    }
    #restartBtn:hover { background: #434668;}
    #pseudoModal {
      display: flex; flex-direction: column;
      position: absolute; left: 50%; top: 34%;
      transform: translate(-50%,-50%);
      background: #232445ee;
      border-radius: 14px;
      box-shadow: 0 8px 24px #0009;
      padding: 32px 42px 32px 32px;
      align-items: center;
      gap: 18px;
      z-index: 100;
    }
    #pseudoModal input[type="text"] {
      font-size: 1.4rem; border-radius: 9px;
      border: 1.5px solid #383b57; padding: 8px 16px; background: #15172a; color: #fff; width: 180px;
      outline: none; transition: border .15s;
    }
    #pseudoModal input[type="color"] {
      width: 38px; height: 38px; border-radius: 50%; border: none; outline: 2px solid #353871; background: #15172a;
    }
    #pseudoModal button {
      font-size: 1.25rem; padding: 7px 34px; border-radius: 10px; border: none;
      background: #28ffe1; color: #111; font-weight: bold; cursor: pointer;
      box-shadow: 0 2px 12px #0004;
    }
    #playersList {
      color: #b2b7e7; margin-top: 18px; font-size: 1.04rem;
      text-align: left;
    }
    #minimap {
      position:absolute;
      bottom:22px;
      right:22px;
      box-shadow:0 2px 8px #0008;
      border-radius:11px;
      background:#17192d;
      border:1.5px solid #393b66;
      z-index:30;
    }
    canvas {
      display: block;
      background: #17192d;
      margin: 0 auto;
      box-shadow: 0 4px 64px #0008;
      border-radius: 18px;
      border: 2px solid #22254a;
    }
    @media (max-width: 960px) {
      canvas {width: 100vw !important; height: 90vh !important;}
      #minimap {width: 90px !important; height: 90px !important;}
    }
  </style>
</head>
<body>
  <canvas id="game" width="900" height="650"></canvas>
  <canvas id="minimap" width="160" height="160"></canvas>
  <div id="ui">
    <div id="score">Score: 0</div>
    <button id="restartBtn">RECOMMENCER</button>
  </div>
  <div id="pseudoModal">
    <h2 style="color:#fff;margin:0;">Slither.io Multi</h2>
    <label style="color:#fff;">Pseudo :</label>
    <input type="text" id="pseudoInput" maxlength="16" value="Visiteur">
    <label style="color:#fff;">Couleur du serpent :</label>
    <input type="color" id="colorInput" value="#39ffe1">
    <button id="startBtn">Jouer</button>
    <div id="playersList"></div>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // --- UI
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const minimap = document.getElementById("minimap");
    const minimapCtx = minimap.getContext("2d");
    const scoreDiv = document.getElementById("score");
    const restartBtn = document.getElementById("restartBtn");
    const pseudoModal = document.getElementById("pseudoModal");
    const pseudoInput = document.getElementById("pseudoInput");
    const colorInput = document.getElementById("colorInput");
    const startBtn = document.getElementById("startBtn");
    const playersListDiv = document.getElementById("playersList");

    // --- Variables de jeu
    let myId = null, mySnake = [], myScore = 0, myDead = false, myColor = "#39ffe1", myPseudo = "";
    let players = {}, balls = [];
    let camera = { x: 0, y: 0 };
    let mouse = { x: 0, y: 0 };
    let fieldSize = 3000;
    let animationId = null;

    // Buffer pour positions reçues du serveur pour le snake du joueur
    let mySnakeBuffer = [];

    // --- Connexion
    const socket = io();

    // --- Rejoindre la partie
    function joinGame() {
      myColor = colorInput.value;
      myPseudo = pseudoInput.value || "Visiteur";
      socket.emit("join", { username: myPseudo, color: myColor });
    }

    // --- Réception de l'état initial
    socket.on("init", data => {
      myId = data.id;
      players = {};
      for (let p of data.players) players[p.id] = p;
      balls = data.balls;
      fieldSize = data.fieldSize || 3000;
      myDead = false;
      pseudoModal.style.display = "none";
      restartBtn.style.display = "none";
      camera = { x: players[myId].x, y: players[myId].y };
      mySnakeBuffer = [];
      mainLoop();
    });

    // --- Mise à jour continue des états
    socket.on("state", data => {
      for (let pid in data.players) {
        players[pid] = data.players[pid];
      }
      balls = data.balls;
      if (players[myId]) {
        myScore = players[myId].score || 0;
        myDead = players[myId].dead;
        // Ajoute la position reçue dans le buffer
        if (players[myId].snake && players[myId].snake[0]) {
          mySnakeBuffer.push({ x: players[myId].snake[0].x, y: players[myId].snake[0].y, t: Date.now() });
          // Garde le buffer petit
          if (mySnakeBuffer.length > 10) mySnakeBuffer.shift();
        }
        mySnake = players[myId].snake;
      }
      if (myDead) {
        restartBtn.style.display = "block";
        scoreDiv.innerHTML = `<span style="color:#ff2a53;">Perdu !</span><br>Score: ${myScore}`;
        cancelAnimationFrame(animationId);
      }
    });

    socket.on("eat_ball", ({playerId, ballId}) => {});
    socket.on("player_dead", ({id, score, reason}) => {});
    socket.on("player_joined", p => { players[p.id] = p; });
    socket.on("player_left", ({id}) => { delete players[id]; });
    socket.on("player_restart", p => {
      if (players[p.id]) {
        players[p.id].dead = false;
        players[p.id].snake = p.snake;
      }
    });

    // --- Contrôles
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      mouse.x = camera.x + (mx - canvas.width/2);
      mouse.y = camera.y + (my - canvas.height/2);
    });
    canvas.addEventListener('touchmove', e => {
      if (!e.touches[0]) return;
      const rect = canvas.getBoundingClientRect();
      const mx = e.touches[0].clientX - rect.left;
      const my = e.touches[0].clientY - rect.top;
      mouse.x = camera.x + (mx - canvas.width/2);
      mouse.y = camera.y + (my - canvas.height/2);
      e.preventDefault();
    }, { passive: false });

    // --- Restart
    restartBtn.onclick = () => {
      socket.emit("restart");
      restartBtn.style.display = "none";
      scoreDiv.innerText = "Score: 0";
      myDead = false;
      mySnakeBuffer = [];
      mainLoop();
    };
    startBtn.onclick = joinGame;
    pseudoInput.onkeydown = e => {if (e.key === "Enter") joinGame();};

    // --- Boucle principale
    function mainLoop() {
      if (myDead) return;
      animationId = requestAnimationFrame(mainLoop);
      // Toujours envoyer la position souris, même si rien ne bouge (pour mouvement continu)
      socket.emit("move", { mouse: { x: mouse.x, y: mouse.y } });

      // Caméra ultra fluide : interpole entre deux positions récentes du buffer
      if (mySnakeBuffer.length > 1) {
        let now = Date.now();
        let [prev, next] = [mySnakeBuffer[mySnakeBuffer.length - 2], mySnakeBuffer[mySnakeBuffer.length - 1]];
        let dt = next.t - prev.t;
        let k = dt ? Math.min(1, (now - next.t + 25) / dt) : 1;
        camera.x += ((prev.x + (next.x - prev.x) * k) - camera.x) * 0.23;
        camera.y += ((prev.y + (next.y - prev.y) * k) - camera.y) * 0.23;
      } else if (mySnake && mySnake[0]) {
        camera.x += ((mySnake[0].x || 0) - camera.x) * 0.16;
        camera.y += ((mySnake[0].y || 0) - camera.y) * 0.16;
      }

      draw();
      drawMinimap();
    }

    // --- Dessin du jeu principal
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Fond damier
      let gridSize = 54;
      let x0 = -((camera.x - canvas.width/2) % gridSize);
      let y0 = -((camera.y - canvas.height/2) % gridSize);
      ctx.save();
      ctx.globalAlpha = 0.15;
      ctx.strokeStyle = "#7b7ea544";
      for (let x = x0; x < canvas.width; x += gridSize) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
      }
      for (let y = y0; y < canvas.height; y += gridSize) {
        ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
      }
      ctx.restore();

      // Billes
      for (let b of balls) {
        let bx = b.x - camera.x + canvas.width/2;
        let by = b.y - camera.y + canvas.height/2;
        drawBall(bx, by, 9, b.color);
      }

      // Serpents (tous)
      for (let pid in players) {
        let p = players[pid];
        if (!p.snake || p.snake.length < 2) continue;
        let col = p.color || "#39ffe1";
        let isMe = (pid === myId);
        for (let i = p.snake.length-1; i > 0; i--) {
          let seg = p.snake[i];
          let px = seg.x - camera.x + canvas.width/2;
          let py = seg.y - camera.y + canvas.height/2;
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.beginPath();
          ctx.arc(px, py, 20, 0, 2*Math.PI);
          ctx.fillStyle = col;
          ctx.shadowColor = col;
          ctx.shadowBlur = 14;
          ctx.fill();
          ctx.restore();
        }
        for (let i = p.snake.length-1; i > 0; i--) {
          let seg = p.snake[i];
          let px = seg.x - camera.x + canvas.width/2;
          let py = seg.y - camera.y + canvas.height/2;
          ctx.save();
          ctx.beginPath();
          ctx.arc(px, py, 14, 0, 2*Math.PI);
          ctx.fillStyle = col;
          ctx.shadowColor = "#000c";
          ctx.shadowBlur = 6;
          ctx.globalAlpha = (0.3 + 0.7*i/p.snake.length);
          ctx.fill();
          ctx.restore();
        }
        // Tête
        let h = p.snake[0];
        let hx = h.x - camera.x + canvas.width/2;
        let hy = h.y - camera.y + canvas.height/2;
        ctx.save();
        ctx.beginPath();
        ctx.arc(hx, hy, 16, 0, 2*Math.PI);
        ctx.fillStyle = "#fff";
        ctx.globalAlpha = 0.27;
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#fff";
        ctx.fill();
        ctx.restore();
        ctx.save();
        ctx.beginPath();
        ctx.arc(hx, hy, 14, 0, 2*Math.PI);
        ctx.fillStyle = col;
        ctx.shadowBlur = 15;
        ctx.shadowColor = col;
        ctx.globalAlpha = 1;
        ctx.fill();
        ctx.restore();

        // Yeux
        if (p.snake.length > 2) {
          let dir = Math.atan2(p.snake[0].y - p.snake[2].y, p.snake[0].x - p.snake[2].x);
          let eyeOff = 7, eyeRad = 4, pupilRad = 2;
          for (let side of [-1, 1]) {
            let ex = hx + Math.cos(dir + side*0.30) * eyeOff;
            let ey = hy + Math.sin(dir + side*0.30) * eyeOff;
            ctx.beginPath(); ctx.arc(ex, ey, eyeRad, 0, 2*Math.PI);
            ctx.fillStyle = "#fff"; ctx.globalAlpha = 0.85; ctx.fill();
            ctx.beginPath(); ctx.arc(ex, ey, pupilRad, 0, 2*Math.PI);
            ctx.fillStyle = "#111"; ctx.globalAlpha = 0.88; ctx.fill();
          }
        }
        // Pseudo
        ctx.save();
        ctx.font = 'bold 14px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = isMe ? "#ffe944" : "#fff";
        ctx.shadowColor = "#000";
        ctx.shadowBlur = 6;
        ctx.globalAlpha = 0.92;
        ctx.fillText(p.username || '', hx, hy - 20);
        ctx.restore();
      }
      scoreDiv.innerText = "Score: " + (myScore || 0);
    }

    function drawBall(x, y, r, color) {
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r+3, 0, 2*Math.PI);
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = color;
      ctx.shadowBlur = 18;
      ctx.shadowColor = color;
      ctx.fill();
      ctx.restore();
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, 2*Math.PI);
      ctx.fillStyle = color;
      ctx.shadowBlur = 3;
      ctx.shadowColor = color;
      ctx.globalAlpha = 0.95;
      ctx.fill();
      ctx.restore();
    }

    // --- Mini-map
    function drawMinimap() {
      minimapCtx.clearRect(0,0,minimap.width,minimap.height);
      minimapCtx.save();
      minimapCtx.strokeStyle = "#fff6";
      minimapCtx.lineWidth = 1.5;
      minimapCtx.strokeRect(0.5, 0.5, minimap.width-1, minimap.height-1);
      minimapCtx.restore();
      let scale = minimap.width/fieldSize;
      for (let pid in players) {
        let p = players[pid];
        if (!p.snake || p.snake.length < 1) continue;
        let last = p.snake[0];
        minimapCtx.save();
        minimapCtx.beginPath();
        minimapCtx.arc(last.x*scale, last.y*scale, pid === myId ? 7 : 4, 0, 2*Math.PI);
        minimapCtx.fillStyle = pid === myId ? "#ffe944" : p.color;
        minimapCtx.globalAlpha = pid === myId ? 0.96 : 0.69;
        minimapCtx.shadowColor = p.color;
        minimapCtx.shadowBlur = pid === myId ? 8 : 2;
        minimapCtx.fill();
        minimapCtx.restore();
      }
    }

    // --- Responsive
    function resize() {
      let w = Math.min(window.innerWidth, 900);
      let h = Math.min(window.innerHeight, 650);
      canvas.width = w; canvas.height = h;
      if (window.innerWidth < 700) {
        minimap.width = 90; minimap.height = 90;
      } else {
        minimap.width = 160; minimap.height = 160;
      }
    }
    resize();
    window.addEventListener('resize', resize);

    function updatePlayersList() {
      socket.emit("request_balls");
      let html = "";
      let arr = Object.values(players).filter(p=>!p.dead).sort((a,b)=>b.score-a.score);
      arr.forEach(p => {
        html += `<span style="color:${p.color};font-weight:bold">${p.username||''}</span> <small>(${p.score})</small><br>`;
      });
      playersListDiv.innerHTML = "<b>Joueurs connectés :</b><br>" + html;
    }
    setInterval(updatePlayersList, 1000);

    window.addEventListener("keydown", e => {
      if (e.key === "Enter" && pseudoModal.style.display !== "none") joinGame();
    });
  </script>
</body>
</html>
